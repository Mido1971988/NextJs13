**** NextJs 13 ( Dave-Gary) *****
https://nextjs.org/docs


* why NextJs?
    1.Server-side rendering (SSR):  can improve website performance and user experience by pre-rendering pages and sending fully-formed HTML to the browser.
    2.Automatic code splitting: Next js automatically splits code into smaller chunks, making it easier to load and reducing the time it takes to load the site.
    3.SEO optimization
    4.Faster development: Next js includes many features that can speed up development, such as file-based routing, automatic code splitting, and built-in API routes.
    5.Great developer experience: Next js offers a great developer experience, including hot reloading, automatic code splitting, and easy integration with other popular technologies.
    6.Built-in support for TypeScript
    * note : Hot reload : is a feature that lets you inject updated source code into a running app. This means that you can see the effects of your code changes almost instantly, without waiting for the app to rebuild or relaunch.

* Hydration: 
    Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive.

* SSG ( static site generation ) vs SSR Server-side Rendering : 
    -Static Generation (Recommended): The HTML is generated at build time and will be reused on each request.
    -Server-side Rendering: The HTML is generated on each request.
    * you can use both method and that called hybrid nextJs 

* CDN(content delivery network): 
    CDN is a network of servers linked together with the goal of delivering content as quickly, cheaply, reliably, and securely as possible.

* to insall nextJs : npx create-next-app@latest

* layout.tsx : any code will be written there will be applied to all pages ( in layout.tsx in app folder)
    each page can have specific layout so code inside it will be applied to this specific page only ( in layout.tsx in about folder ).

* Metadata : is availabe at layout.tsx and each page can have layout.tsx file inside it you can add different Metadata ( you can also add Metadata at page.tsx)

* loading : you can add loading.tsx file to any page folder and you will see it if page take too long for loading

* error handling : you can add error.tsx to any page folder and will render it when there is an error and will not crash all project

* Routes : 
    just create folder and the name of folder will be the route name then add page.tsx file inside it

* Dynamic Routes : 
    just create a folder and the name of the folder between [] ( like [userId] inside users folder) :

* types.d.ts : you can create this file and add all types you will need in project and you can use it directly without importing 

* Fetching Data : 
    - you can fetch data inside function inside page.tsx file but it's better for organization add those functions 
    inside lib folder and then import them like ( import getAllUsers from '@/lib/getAllUsers' )

    - in page.tsx of users folder :
        * we fetched data of user and rendered the users name
        * we added Metadata directly at page.tsx
        * const usersData: Promise<User[]> = getAllUsers() 
            because getAllUsers() will return promise and we added <User[]> for types (User type from types.d.ts file)
    
    in page.tsx of [userId] : 
        * we created Dynamic Metadata (generateMetadata function and it's params is userId from Url )
        * we have 2 options to do 2 fetch requests : 
            [1] parallel ( use Promise.all([userData, userPostsData])) will fetch 2 request at same time
            [2] Suspense to progressively render a page and show a result to the user while the rest of the content loads 
                steps of option 2 : 
                    [a] import { Suspense } from "react"
                    [b] wrap the UserPosts component with Suspense component and pass the Promise as prop
                    * note : Suspense component can accept a fallback prop to render it when loading ( fallback={<h2>Loading...</h2>}) 

        * note : in option 1 we will fetch userData, userPostsData at same time so maybe will take a long time
        so option 2 is better because you will fetch userData first to show user.name and Suspense userPostsData to show userPosts when it ready

* in page.tsx in [userId] folder we fetched two times by invoking getUser() function two times 
but in nextjs by default will combine those 2 fetches to one fetch.

- Any <Link /> component will be prefetched by default
    For example : you have home page and have users page 
    When you at home page will not fetch the data untill you go to homepage\users from address bar in browser ( will download html file from server ) 
    But if you add Link to this users page at home page will fetch data when you open home page and you have two options : 
        [1] when you go to users page from address bar will download users html file from the server
        [2] when you click on the link will not download users html file from server will use fetched data to create html at client side
        * note : both 2 options data will be fetched on home page to be ready if you click on the link

* SSG : Static Site Generation
* SSR : Server Site Rendering ( for Dynamic Routes for example)
* ISR : incremental Static Generation ( allows pages to be updated after a site has been built and deployed )

* SSG vs SSR : 
    [1] Static Site Generation is a technique for pre-rendering web pages , during the build process. 
    The generated HTML, CSS, and JavaScript files are then served to the client, 
    resulting in websites loading faster and providing heightened security.

    [2] Server Side Rendering  is a technique where web pages are rendered on the server at request time for each user. 
    This approach allows for dynamic data and interactive content to be generated on-the-fly, 
    providing a more personalized user experience.

* how to change SSR to SSG : 
    for Example you have dynamic routes [userId] so nextjs will consider it as SSR because it does not know 
    the numbers of userId but if you know you can tell nextJs what is the expected userId (by generateStaticParams())
    we created generateStaticParams() function inside page.tsx inside [userId] folder 
    and this function will return array of objects each object has userId prop
    now nextjs knows the expected userId so will convert users/[userId] from SSR to SSG

* 2nd parameter of fetch : 
    [1] fetch(url, {cache: "force-cache"}) this if the defaut Nextjs cache data by default
    [2] fetch(url, {cache: "no-store"}) will not cache data 
    [3] fetch(url, {next: {revalidate : 60 }}) will check every 60 sec if there is updated data or not
        and this can applied to SSG or SSR (this method is called ISR) (in getUserPosts.tsx)

* Revalidation : is the process of purging the Data Cache and re-fetching the latest data. 
    This is useful when your data changes and you want to ensure you show the latest information.
    steps of Revalidation : 
    when you request data for first time will fetch data and for example you added {next: {revalidate : 60 }}
        -if you request data again before 60 sec will give you the data from cache
        -if you request data after 60 sec will fetch a new data

* dynamicParams: you can add export const dynamicParams = false; to page.tsx inside [userId] folder
    so when you try to access page not returned from generateStaticParams() ( like users/999 ) will give you 404 page
    * note: the default value is  dynamicParams = true so you can access any page number because it's dynamic
    * note : maybe is a bug if generateStaticParams()  return({userId:1}, {userId:2} , ...) dynamicParams = false; will work
        but if generateStaticParams()  return(users.map(user=>{userId:user.id.toString()})) dynamicParams = false; will not work

* not-found page : 
    nextjs by default give you 404 not found page if you write wrong url
    but you can override it by creating not-found.tsx inside App folder

    * note : you can show 404 page to dynamic route 
        for example if you write users/999 will render blank page because you are using 
        dynamic route so will accept any number
        but you can use notFound() function : 
            [a] import {notFound} from "next/navigation"
            [b] if(!user.name) return  notFound()
        so when you write users/999 user.name not availabe because so will give you 404 page (or not-found.tsx page if you override it )

* API routes : 
    - you can create api inside directory (app/api/folderName/route.ts)
        export async function GET(){
            return new Response("Hello, nextJs")
            return NextResponse.json("Hello, nextJs")
        }
        * note : instead of returning response.json() we will use NextResponse.json() because response.json() not compatible with TypeScript
        * note : you can use POST or GET
        * note : to test api you can download Thunder Client extension in VSCODE
        * note : we created feedback page.tsx that uses feedback route.ts api (see files to understand)
        * note : Array.protoype.every(Boolean) will check if every element in array is truthy value (const canSave = [...Object.values(data)].every(Boolean) in page.tsx in feddback page folder)

    - we usually use API routes in nextjs to hide secret key or secret URL 
    - if you are fetching data in server component no need to use API routes because already hidden from client side
    - if you want github ignore a file and not upload it to repo add name of file to .gitignore 
    - you can put you API KEY in .env.local file and github will not upload it to reop because it's mentioned in .gitignore file
    - you can add dynamic route folder ( like [id] inside todos folder inside api folder) 
    * note : const { id }: Partial<Todo> ( in route.ts in todos folder) Partial means i can write only id without typescript error no need to write all properties

* difference between PUT , POST , DELETE ? 
    The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server. 
    The PUT method replaces all current representations of the target resource with the request payload. 
    The DELETE method deletes the specified resource

